\section*{Principaux algorithmes}
\subsection*{Mouvements des pièces}
Pour le mouvement des pièces, nous avons choisi de le représenter comme
un arbre des positions. Un noeud et ses parents représentent tout le 
chemin pour arriver à la position au noeud. [EXEMPLE]. C'est un choix
plutôt exotique, mais justifiable. En effet, si nous avions implémenté
ceci comme un ensemble, il y aurait ambiguité dans notre exemple.
On ne sait pas le chemin à prendre dans le cas des sauts multiples. Or,
avec un arbre, il suffit de remonter l'arbre et nous avons le chemin
emprunté.


\subsection*{structure du jeu}

\begin{minted}{c}
typedef struct {
    uint turn;
    uint max_turns;
    player_t *current_player;
    enum victory_type victory_type;
    struct world_t *world;
    array_list_t *captured_pieces_list;
    array_list_t *starting_position;
} game_t;
\end{minted}


Notre structure game\_t comprend tous les éléments nécessaire pour le déroulement d'une partie du jeu.


